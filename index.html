<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>./ GRAD DODGE v5</title>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet" />
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: 'Press Start 2P', monospace;
      height: 100vh;
      overflow: hidden;
      background: #0a0a0a;
      color: #00ff41;
      position: relative;
    }

    #bg-grid {
      position: fixed;
      top: 0; left: 0;
      width: 100%;
      height: 100%;
      font-size: 12px;
      line-height: 16px;
      opacity: 0.25;
      pointer-events: none;
      z-index: 1;
      white-space: pre;
      font-family: 'Courier New', monospace;
      user-select: none;
      color: #00ff41;
      animation: gridGlow 3s ease-in-out infinite alternate;
    }

    @keyframes gridGlow {
      0% { opacity: 0.15; color: #00aa28; }
      100% { opacity: 0.35; color: #00ff41; }
    }

    body.glitch #bg-grid {
      animation: gridGlitch 0.12s linear infinite;
      opacity: 0.5;
      filter: hue-rotate(45deg);
    }
    @keyframes gridGlitch {
      0% { opacity: 0.12; transform: translate(0, 0); }
      20% { opacity: 0.55; transform: translate(-1px, 0); }
      40% { opacity: 0.20; transform: translate(2px, 1px); }
      60% { opacity: 0.60; transform: translate(-2px, -1px); }
      80% { opacity: 0.25; transform: translate(1px, -1px); }
      100% { opacity: 0.45; transform: translate(0, 0); }
    }

    #menu {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      z-index: 10;
    }

    h1 {
      font-size: 32px;
      margin-bottom: 40px;
      text-shadow: 0 0 10px #00ff41;
      animation: glow 2s ease-in-out infinite alternate;
    }

    @keyframes glow {
      from { text-shadow: 0 0 10px #00ff41; }
      to { text-shadow: 0 0 20px #00ff41, 0 0 30px #00ff41; }
    }

    .btn {
      background: #00ff41;
      color: #000;
      border: none;
      padding: 18px 36px;
      font-family: 'Press Start 2P', monospace;
      font-size: 16px;
      cursor: pointer;
      margin: 12px;
      box-shadow: 0 0 20px rgba(0, 255, 65, 0.5);
      transition: all 0.3s;
      user-select: none;
    }

    .btn:hover {
      background: #00cc33;
      box-shadow: 0 0 30px rgba(0, 255, 65, 0.8);
      transform: scale(1.05);
    }

    .btn-small {
      padding: 10px 20px;
      font-size: 12px;
      margin: 6px;
    }

    .btn-active {
      background: #00ccff;
      box-shadow: 0 0 20px rgba(0, 204, 255, 0.8);
    }

    #gameCanvas {
      position: fixed;
      top: 0; left: 0;
      width: 100vw;
      height: 100vh;
      image-rendering: pixelated;
      background: rgba(0, 0, 0, 0.9);
      display: none;
      z-index: 5;
    }

    #ui {
      position: fixed;
      top: 20px;
      left: 20px;
      z-index: 15;
      font-size: 14px;
      text-shadow: 0 0 5px #00ff41;
      user-select: none;
      opacity: 0;
      transition: opacity 0.3s, color 0.1s;
      line-height: 1.4;
      color: #00ff41;
    }

    body.glitch #ui {
      color: #ff44ff;
      text-shadow: 0 0 8px #ff44ff;
    }

    #ui span { margin-right: 12px; display: block; }

    .status-on { color: #00ff41; text-shadow: 0 0 8px #00ff41; }
    .status-off { color: #666; }

    #gameOver {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.95);
      border: 4px solid #ff0040;
      padding: 50px;
      text-align: center;
      display: none;
      z-index: 20;
      box-shadow: 0 0 40px rgba(255, 0, 64, 0.5);
      user-select: none;
    }

    #finalScore {
      font-size: 24px;
      margin: 18px 0;
      color: #ff0040;
      text-shadow: 0 0 10px #ff0040;
    }

    #finalBest {
      font-size: 18px;
      margin-bottom: 10px;
      color: #ccc;
    }

    #bestBlock {
      font-size: 12px;
      margin-top: 12px;
      color: #aaa;
      line-height: 1.8;
    }
  </style>
</head>
<body>
  <div id="bg-grid"></div>

  <div id="ui">
    <span id="time">TIME: 60s</span>
    <span id="score">SCORE: 0</span>
    <span id="shield"><span class="status-off">SHIELD: OFF</span></span>
    <span id="slowmo"><span class="status-off">SLOWMO: OFF</span></span>
    <span id="mult"><span class="status-off">X2: OFF</span></span>
    <span id="magnet"><span class="status-off">+M+: OFF</span></span>
    <span id="glitch"><span class="status-off">GLITCH: OFF</span></span>
    <span id="diffLabel">DIFF: EASY</span>
    <span id="modeLabel">MODE: ARCADE</span>
  </div>

  <div id="menu">
    <h1>./ GRAD DODGE v5</h1>
    <p>– Dodge X enemies!</p>
    <p>– Collect + for +10 points!</p>
    <p>– Collect * for SHIELD (1 hit)!</p>
    <p>– Collect S to SLOW TIME!</p>
    <p>– Collect X2 for SCORE x2!</p>
    <p>– Collect +M+ for MAGNET!</p>
    <p>– GLITCH: world movement can invert</p>
    <br />

    <div id="difficultyButtons">
      <button class="btn btn-small btn-active" data-diff="easy">EASY</button>
      <button class="btn btn-small" data-diff="normal">NORMAL</button>
      <button class="btn btn-small" data-diff="hard">HARD</button>
    </div>

    <div id="modeButtons">
      <button class="btn btn-small btn-active" data-mode="arcade">ARCADE (60s)</button>
      <button class="btn btn-small" data-mode="survival">SURVIVAL (∞)</button>
      <button class="btn btn-small" data-mode="glitch">GLITCH (60s)</button>
    </div>

    <br/>
    <button class="btn" id="startBtn">./ START GAME</button>

    <div id="bestBlock">
      <div>
        BEST ARCADE EASY: <span id="bestArcadeEasy">0</span> |
        BEST ARCADE NORMAL: <span id="bestArcadeNormal">0</span> |
        BEST ARCADE HARD: <span id="bestArcadeHard">0</span>
      </div>
      <div>
        BEST SURVIVAL EASY: <span id="bestSurvivalEasy">0</span> |
        BEST SURVIVAL NORMAL: <span id="bestSurvivalNormal">0</span> |
        BEST SURVIVAL HARD: <span id="bestSurvivalHard">0</span>
      </div>
      <div>
        BEST GLITCH EASY: <span id="bestGlitchEasy">0</span> |
        BEST GLITCH NORMAL: <span id="bestGlitchNormal">0</span> |
        BEST GLITCH HARD: <span id="bestGlitchHard">0</span>
      </div>
    </div>
  </div>

  <canvas id="gameCanvas"></canvas>

  <div id="gameOver">
    <h2>./ GAME OVER</h2>
    <div id="finalScore">FINAL SCORE: 0</div>
    <div id="finalBest">BEST (MODE): 0</div>
    <button class="btn" id="restartBtn">./ RESTART</button>
    <br /><br />
    <button class="btn" id="menuBtn" style="background: #666;">./ MAIN MENU</button>
  </div>

  <script>
    function createBgGrid() {
      const grid = document.getElementById('bg-grid');
      let content = '';
      const cols = Math.floor(window.innerWidth / 14);
      const rows = Math.floor(window.innerHeight / 16);
      for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) content += './';
        content += '\n';
      }
      grid.textContent = content;
    }
    createBgGrid();
    window.addEventListener('resize', createBgGrid);

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      ctx.imageSmoothingEnabled = false;
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    const GLOBAL_GAME_TIME = 60000;
    const POWERUP_DURATION = 5000;

    const PLAYER_SIZE = 28;
    const FONT = 'bold 26px monospace';

    const GLITCH_SCORE_BONUS = 1.25;    
    const GLITCH_MIN_COOLDOWN = 10000;  
    const GLITCH_MAX_COOLDOWN = 15000;  
    const GLITCH_MIN_DURATION = 4000;   
    const GLITCH_MAX_DURATION = 6000;  

    const GLITCH_DRIFT_SPEED = 3.2;

    const difficulties = {
      easy: {
        label: 'EASY',
        enemySpawnBase: 0.055,
        enemySpeedBase: { min: 1.6, max: 3.1 },
        plusChance: 0.03,
        shieldChance: 0.012,
        slowmoChance: 0.012,
        multChance: 0.012,
        magnetChance: 0.01
      },
      normal: {
        label: 'NORMAL',
        enemySpawnBase: 0.07,
        enemySpeedBase: { min: 2.1, max: 4.6 },
        plusChance: 0.018,
        shieldChance: 0.007,
        slowmoChance: 0.007,
        multChance: 0.01,
        magnetChance: 0.008
      },
      hard: {
        label: 'HARD',
        enemySpawnBase: 0.09,
        enemySpeedBase: { min: 2.7, max: 5.7 },
        plusChance: 0.015,
        shieldChance: 0.002,
        slowmoChance: 0.002,
        multChance: 0.008,
        magnetChance: 0.006
      }
    };

    const modes = {
      arcade: { label: 'ARCADE', hasTimeLimit: true, glitchEnabled: false },
      survival: { label: 'SURVIVAL', hasTimeLimit: false, glitchEnabled: false },
      glitch: { label: 'GLITCH', hasTimeLimit: true, glitchEnabled: true }
    };

    let currentDifficultyKey = 'easy';
    let currentModeKey = 'arcade';
    let gameConfig = { ...difficulties[currentDifficultyKey] };

    const HS_KEY = 'dodgePlusHighscores_v4_world_glitch';

    function emptyHighscores() {
      return {
        arcade_easy: 0, arcade_normal: 0, arcade_hard: 0,
        survival_easy: 0, survival_normal: 0, survival_hard: 0,
        glitch_easy: 0, glitch_normal: 0, glitch_hard: 0
      };
    }

    function loadHighscores() {
      try {
        const raw = localStorage.getItem(HS_KEY);
        if (!raw) return emptyHighscores();
        const parsed = JSON.parse(raw);
        return { ...emptyHighscores(), ...parsed };
      } catch {
        return emptyHighscores();
      }
    }

    function saveHighscores() {
      localStorage.setItem(HS_KEY, JSON.stringify(highscores));
    }

    function makeHSKey(modeKey, diffKey) {
      return `${modeKey}_${diffKey}`;
    }

    function updateBestBlock() {
      document.getElementById('bestArcadeEasy').textContent = highscores.arcade_easy || 0;
      document.getElementById('bestArcadeNormal').textContent = highscores.arcade_normal || 0;
      document.getElementById('bestArcadeHard').textContent = highscores.arcade_hard || 0;

      document.getElementById('bestSurvivalEasy').textContent = highscores.survival_easy || 0;
      document.getElementById('bestSurvivalNormal').textContent = highscores.survival_normal || 0;
      document.getElementById('bestSurvivalHard').textContent = highscores.survival_hard || 0;

      document.getElementById('bestGlitchEasy').textContent = highscores.glitch_easy || 0;
      document.getElementById('bestGlitchNormal').textContent = highscores.glitch_normal || 0;
      document.getElementById('bestGlitchHard').textContent = highscores.glitch_hard || 0;
    }

    function tryUpdateHighscore(modeKey, diffKey, score) {
      const k = makeHSKey(modeKey, diffKey);
      if (score > (highscores[k] || 0)) {
        highscores[k] = score;
        saveHighscores();
        updateBestBlock();
        return true;
      }
      return false;
    }

    let highscores = loadHighscores();
    updateBestBlock();

    const keys = {};
    document.addEventListener('keydown', (e) => {
      keys[e.code] = true;
      if (e.code === 'Space' && !gameRunning) e.preventDefault();
    });
    document.addEventListener('keyup', (e) => keys[e.code] = false);

    let gameRunning = false;

    let player = { x: 0, y: 0, size: PLAYER_SIZE };
    let enemies = [];
    let collectibles = [];
    let score = 0;
    let startTime = 0;
    let scoreMultiplier = 1;

    const powerups = {
      shield: { active: false, endTime: 0 },
      slowmo: { active: false, endTime: 0 },
      mult: { active: false, endTime: 0 },
      magnet: { active: false, endTime: 0 }
    };

    let glitchState = {
      active: false,
      endTime: 0,
      nextTime: 0,
      type: 'invert' 
    };

    function randInt(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    function scheduleNextGlitch(now) {
      glitchState.nextTime = now + randInt(GLITCH_MIN_COOLDOWN, GLITCH_MAX_COOLDOWN);
    }

    function setGlitchUI(on) {
      const el = document.getElementById('glitch');
      const status = el.querySelector('span');
      status.textContent = on ? `GLITCH: ON (${glitchState.type.toUpperCase()})` : 'GLITCH: OFF';
      status.className = on ? 'status-on' : 'status-off';
      document.body.classList.toggle('glitch', !!on);
    }

    function startGlitch(now) {
      glitchState.active = true;
      glitchState.type = Math.random() < 0.5 ? 'invert' : 'swap';
      glitchState.endTime = now + randInt(GLITCH_MIN_DURATION, GLITCH_MAX_DURATION);
      setGlitchUI(true);
    }

    function stopGlitch() {
      glitchState.active = false;
      glitchState.endTime = 0;
      setGlitchUI(false);
    }

    function createEnemy(difficultyFactor = 1) {
      return {
        x: Math.random() * (canvas.width - PLAYER_SIZE) + PLAYER_SIZE / 2,
        y: -PLAYER_SIZE,
        size: PLAYER_SIZE,
        speed: gameConfig.enemySpeedBase.min +
          Math.random() * (gameConfig.enemySpeedBase.max - gameConfig.enemySpeedBase.min) * difficultyFactor
      };
    }

    function createCollectible(type) {
      return {
        type: type || '+',
        x: Math.random() * (canvas.width - PLAYER_SIZE * 2) + PLAYER_SIZE,
        y: -PLAYER_SIZE,
        size: PLAYER_SIZE,
        speed: 1.5 + Math.random() * 1.5
      };
    }

    function collided(a, b) {
      const dx = a.x - b.x;
      const dy = a.y - b.y;
      return Math.sqrt(dx * dx + dy * dy) < (a.size / 2 + b.size / 2) * 0.9;
    }

    function clampPlayer() {
      player.x = Math.max(player.size / 2, Math.min(canvas.width - player.size / 2, player.x));
      player.y = Math.max(player.size / 2, Math.min(canvas.height - player.size / 2, player.y));
    }

    function activatePowerup(type) {
      powerups[type].active = true;
      powerups[type].endTime = Date.now() + POWERUP_DURATION;

      const el = document.getElementById(type);
      const status = el.querySelector('span');
      const labels = { shield: 'SHIELD', slowmo: 'SLOWMO', mult: 'X2', magnet: '+M+' };
      status.textContent = labels[type] + ': ON';
      status.className = 'status-on';
    }

    function deactivatePowerup(type) {
      powerups[type].active = false;

      const el = document.getElementById(type);
      const status = el.querySelector('span');
      const labels = { shield: 'SHIELD', slowmo: 'SLOWMO', mult: 'X2', magnet: '+M+' };
      status.textContent = labels[type] + ': OFF';
      status.className = 'status-off';
    }

    function updatePowerups() {
      const now = Date.now();
      for (const type of Object.keys(powerups)) {
        if (powerups[type].active && now >= powerups[type].endTime) deactivatePowerup(type);
      }
      scoreMultiplier = powerups.mult.active ? 2 : 1;
    }

    function addScore(basePoints) {
      const modeBonus = (currentModeKey === 'glitch') ? GLITCH_SCORE_BONUS : 1;
      score += Math.floor(basePoints * scoreMultiplier * modeBonus);
    }

    function readPlayerMove() {
      const baseSpeed = 8;
      const moveSpeed = powerups.slowmo.active ? baseSpeed * 0.7 : baseSpeed;

      let dx = 0, dy = 0;
      if (keys['ArrowLeft'] || keys['KeyA']) dx -= 1;
      if (keys['ArrowRight'] || keys['KeyD']) dx += 1;
      if (keys['ArrowUp'] || keys['KeyW']) dy -= 1;
      if (keys['ArrowDown'] || keys['KeyS']) dy += 1;

      return { vx: dx * moveSpeed, vy: dy * moveSpeed };
    }

    function applyWorldGlitchToVelocity(vx, vy) {
      if (!(modes[currentModeKey].glitchEnabled && glitchState.active)) return { vx, vy };

      if (glitchState.type === 'invert') {
        return { vx: -vx, vy: -vy };
      }

      const swappedVX = vy;                 
      const driftVY = (vx === 0 ? 0 : vx); 
      return { vx: swappedVX, vy: driftVY };
    }

    function moveEnemiesAndItems(slowFactor) {

      for (const e of enemies) {
        let vx = 0;
        let vy = e.speed * slowFactor;

        if (modes[currentModeKey].glitchEnabled && glitchState.active && glitchState.type === 'swap') {
          vx = (Math.random() < 0.5 ? -1 : 1) * GLITCH_DRIFT_SPEED;
        }

        const t = applyWorldGlitchToVelocity(vx, vy);
        e.x += t.vx;
        e.y += t.vy;
      }

      for (const c of collectibles) {
        let vx = 0;
        let vy = c.speed * slowFactor;

        if (modes[currentModeKey].glitchEnabled && glitchState.active && glitchState.type === 'swap') {
          vx = (Math.random() < 0.5 ? -1 : 1) * (GLITCH_DRIFT_SPEED * 0.85);
        }

        const t = applyWorldGlitchToVelocity(vx, vy);
        c.x += t.vx;
        c.y += t.vy;
      }
    }

    function clampObjects() {

      const pad = 120;
      const minX = -pad, maxX = canvas.width + pad;
      const minY = -pad, maxY = canvas.height + pad;

      enemies = enemies.filter(e => e.x > minX && e.x < maxX && e.y > minY && e.y < maxY);
      collectibles = collectibles.filter(c => c.x > minX && c.x < maxX && c.y > minY && c.y < maxY);
    }

    function magnetCollectibles() {
      if (!powerups.magnet.active) return;

      for (let i = collectibles.length - 1; i >= 0; i--) {
        const c = collectibles[i];
        if (c.type !== '+') continue;

        const dx = player.x - c.x;
        const dy = player.y - c.y;
        const dist = Math.sqrt(dx * dx + dy * dy) || 0.0001;

        if (dist < 120) {
          c.x += (dx / dist) * 4;
          c.y += (dy / dist) * 4;
        }

        if (collided(player, c)) {
          addScore(10);
          collectibles.splice(i, 1);
        }
      }
    }

    function update() {
      if (!gameRunning) return;

      const now = Date.now();

      if (modes[currentModeKey].glitchEnabled) {
        if (!glitchState.active && now >= glitchState.nextTime) startGlitch(now);
        if (glitchState.active && now >= glitchState.endTime) {
          stopGlitch();
          scheduleNextGlitch(now);
        }
      } else {
        if (glitchState.active) stopGlitch();
      }

      const mv = readPlayerMove();
      player.x += mv.vx;
      player.y += mv.vy;
      clampPlayer();

      const elapsed = now - startTime;
      const timeFactor = Math.min(1.8, 1 + elapsed / GLOBAL_GAME_TIME);
      const slowFactor = powerups.slowmo.active ? 0.4 : 1;

      moveEnemiesAndItems(slowFactor);
      clampObjects();

      if (Math.random() < gameConfig.enemySpawnBase * timeFactor) enemies.push(createEnemy(timeFactor));
      if (Math.random() < gameConfig.plusChance) collectibles.push(createCollectible('+'));
      if (Math.random() < gameConfig.shieldChance) collectibles.push(createCollectible('shield'));
      if (Math.random() < gameConfig.slowmoChance) collectibles.push(createCollectible('slowmo'));
      if (Math.random() < gameConfig.multChance) collectibles.push(createCollectible('mult'));
      if (Math.random() < gameConfig.magnetChance) collectibles.push(createCollectible('magnet'));

      for (let i = enemies.length - 1; i >= 0; i--) {
        if (collided(player, enemies[i])) {
          if (powerups.shield.active) {
            enemies.splice(i, 1);
            deactivatePowerup('shield');
          } else {
            gameOver();
            return;
          }
        }
      }

      for (let i = collectibles.length - 1; i >= 0; i--) {
        const item = collectibles[i];
        if (!collided(player, item)) continue;

        if (item.type === '+') addScore(10);
        else activatePowerup(item.type);

        collectibles.splice(i, 1);
      }

      magnetCollectibles();
      updatePowerups();

      document.getElementById('score').textContent = `SCORE: ${score}`;

      if (modes[currentModeKey].hasTimeLimit) {
        const timeLeft = Math.max(0, GLOBAL_GAME_TIME - elapsed);
        document.getElementById('time').textContent = `TIME: ${Math.floor(timeLeft / 1000)}s`;
        if (elapsed >= GLOBAL_GAME_TIME) gameWin();
      } else {
        document.getElementById('time').textContent = 'TIME: ∞';
      }
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.font = FONT;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      if (powerups.shield.active) {
        ctx.save();
        ctx.beginPath();
        ctx.arc(player.x, player.y, player.size, 0, Math.PI * 2);
        ctx.strokeStyle = '#00bfff';
        ctx.lineWidth = 3;
        ctx.shadowColor = '#00bfff';
        ctx.shadowBlur = 15;
        ctx.stroke();
        ctx.restore();
      }

      ctx.fillStyle = '#00ff41';
      ctx.shadowColor = '#00ff41';
      ctx.shadowBlur = 12;
      ctx.fillText('./', player.x, player.y);
      ctx.shadowBlur = 0;

      enemies.forEach(e => {
        ctx.fillStyle = '#ff0040';
        ctx.shadowColor = '#ff0040';
        ctx.shadowBlur = 12;
        ctx.fillText('X', e.x, e.y);
        ctx.shadowBlur = 0;
      });

      const colors = {
        '+': '#bb00ff',
        shield: '#00bfff',
        slowmo: '#ffff00',
        mult: '#ff44ff',
        magnet: '#44ff44'
      };
      const icons = { shield: '*', slowmo: 'S', mult: 'X2', magnet: '+M+' };

      collectibles.forEach(c => {
        const color = colors[c.type] || '#bb00ff';
        const icon = icons[c.type] || c.type;
        ctx.fillStyle = color;
        ctx.shadowColor = color;
        ctx.shadowBlur = 12;
        ctx.fillText(icon, c.x, c.y);
        ctx.shadowBlur = 0;
      });
    }

    function gameLoop() {
      update();
      draw();
      requestAnimationFrame(gameLoop);
    }

    // ---------- UI / LIFECYCLE ----------
    function resetPowerupsUI() {
      for (const type of Object.keys(powerups)) {
        powerups[type].active = false;
        powerups[type].endTime = 0;

        const el = document.getElementById(type);
        if (!el) continue;
        const status = el.querySelector('span');
        const labels = { shield: 'SHIELD', slowmo: 'SLOWMO', mult: 'X2', magnet: '+M+' };
        status.textContent = labels[type] + ': OFF';
        status.className = 'status-off';
      }
      scoreMultiplier = 1;
    }

    function startGame() {
      gameConfig = { ...difficulties[currentDifficultyKey] };
      gameRunning = true;

      startTime = Date.now();
      score = 0;

      player.x = canvas.width / 2;
      player.y = canvas.height - 100;

      enemies = [];
      collectibles = [];
      resetPowerupsUI();

      stopGlitch();
      scheduleNextGlitch(Date.now());

      document.getElementById('diffLabel').textContent = `DIFF: ${gameConfig.label}`;
      document.getElementById('modeLabel').textContent = `MODE: ${modes[currentModeKey].label}`;
      document.getElementById('score').textContent = 'SCORE: 0';
      document.getElementById('time').textContent = modes[currentModeKey].hasTimeLimit ? 'TIME: 60s' : 'TIME: ∞';

      document.getElementById('menu').style.display = 'none';
      document.getElementById('gameOver').style.display = 'none';
      canvas.style.display = 'block';
      document.getElementById('ui').style.opacity = '1';
    }

    function showMenu() {
      canvas.style.display = 'none';
      document.getElementById('gameOver').style.display = 'none';
      document.getElementById('menu').style.display = 'block';
      document.getElementById('ui').style.opacity = '0';
      stopGlitch();
    }

    function endGameCommon(title) {
      gameRunning = false;
      stopGlitch();

      const isNewBest = tryUpdateHighscore(currentModeKey, currentDifficultyKey, score);
      const bestForMode = highscores[makeHSKey(currentModeKey, currentDifficultyKey)] || 0;

      document.getElementById('finalScore').textContent = `FINAL SCORE: ${score}`;
      document.getElementById('finalBest').textContent =
        `BEST ${modes[currentModeKey].label} ${gameConfig.label}: ${bestForMode}` + (isNewBest ? ' (NEW!)' : '');

      const go = document.getElementById('gameOver');
      go.style.borderColor = title.includes('WIN') ? '#00ff41' : '#ff0040';
      go.style.boxShadow = `0 0 40px ${title.includes('WIN') ? 'rgba(0, 255, 65, 0.5)' : 'rgba(255, 0, 64, 0.5)'}`;
      go.querySelector('h2').textContent = title;
      go.style.display = 'block';

      bindGameOverButtons();
    }

    function gameOver() { endGameCommon('./ GAME OVER'); }
    function gameWin() { endGameCommon('./ YOU WIN!'); }

    function bindGameOverButtons() {
      document.getElementById('restartBtn').onclick = () => {
        document.getElementById('gameOver').style.display = 'none';
        startGame();
      };
      document.getElementById('menuBtn').onclick = () => {
        document.getElementById('gameOver').style.display = 'none';
        showMenu();
      };
    }

    // ---------- MENU BUTTONS ----------
    document.getElementById('difficultyButtons').addEventListener('click', (e) => {
      const btn = e.target.closest('button[data-diff]');
      if (!btn || !difficulties[btn.dataset.diff]) return;

      currentDifficultyKey = btn.dataset.diff;
      gameConfig = { ...difficulties[currentDifficultyKey] };

      document.querySelectorAll('#difficultyButtons button').forEach(b => b.classList.remove('btn-active'));
      btn.classList.add('btn-active');

      document.getElementById('diffLabel').textContent = `DIFF: ${gameConfig.label}`;
    });

    document.getElementById('modeButtons').addEventListener('click', (e) => {
      const btn = e.target.closest('button[data-mode]');
      if (!btn || !modes[btn.dataset.mode]) return;

      currentModeKey = btn.dataset.mode;

      document.querySelectorAll('#modeButtons button').forEach(b => b.classList.remove('btn-active'));
      btn.classList.add('btn-active');

      document.getElementById('modeLabel').textContent = `MODE: ${modes[currentModeKey].label}`;
    });

    document.getElementById('startBtn').onclick = startGame;

    gameLoop();
  </script>
</body>
</html>
