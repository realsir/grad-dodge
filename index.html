<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>./ GRAD DODGE v4</title>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet" />
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: 'Press Start 2P', monospace;
      height: 100vh;
      overflow: hidden;
      background: #0a0a0a;
      color: #00ff41;
      position: relative;
    }

    #bg-grid {
      position: fixed;
      top: 0; left: 0;
      width: 100%;
      height: 100%;
      font-size: 12px;
      line-height: 16px;
      opacity: 0.25;
      pointer-events: none;
      z-index: 1;
      white-space: pre;
      font-family: 'Courier New', monospace;
      user-select: none;
      color: #00ff41;
      animation: gridGlow 3s ease-in-out infinite alternate;
    }

    @keyframes gridGlow {
      0% { opacity: 0.15; color: #00aa28; }
      100% { opacity: 0.35; color: #00ff41; }
    }

    #menu {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      z-index: 10;
    }

    h1 {
      font-size: 32px;
      margin-bottom: 40px;
      text-shadow: 0 0 10px #00ff41;
      animation: glow 2s ease-in-out infinite alternate;
    }

    @keyframes glow {
      from { text-shadow: 0 0 10px #00ff41; }
      to { text-shadow: 0 0 20px #00ff41, 0 0 30px #00ff41; }
    }

    .btn {
      background: #00ff41;
      color: #000;
      border: none;
      padding: 18px 36px;
      font-family: 'Press Start 2P', monospace;
      font-size: 16px;
      cursor: pointer;
      margin: 12px;
      box-shadow: 0 0 20px rgba(0, 255, 65, 0.5);
      transition: all 0.3s;
      user-select: none;
    }

    .btn:hover {
      background: #00cc33;
      box-shadow: 0 0 30px rgba(0, 255, 65, 0.8);
      transform: scale(1.05);
    }

    .btn-small {
      padding: 10px 20px;
      font-size: 12px;
      margin: 6px;
    }

    .btn-diff-active {
      background: #00ccff;
      box-shadow: 0 0 20px rgba(0, 204, 255, 0.8);
    }

    #gameCanvas {
      position: fixed;
      top: 0; left: 0;
      width: 100vw;
      height: 100vh;
      image-rendering: pixelated;
      background: rgba(0, 0, 0, 0.9);
      display: none;
      z-index: 5;
    }

    #ui {
      position: fixed;
      top: 20px;
      left: 20px;
      z-index: 15;
      font-size: 14px;
      text-shadow: 0 0 5px #00ff41;
      user-select: none;
      opacity: 0;
      transition: opacity 0.3s;
      line-height: 1.4;
    }

    #ui span { margin-right: 12px; display: block; }

    .status-on { color: #00ff41; text-shadow: 0 0 8px #00ff41; }
    .status-off { color: #666; }

    #gameOver {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.95);
      border: 4px solid #ff0040;
      padding: 50px;
      text-align: center;
      display: none;
      z-index: 20;
      box-shadow: 0 0 40px rgba(255, 0, 64, 0.5);
      user-select: none;
    }

    #finalScore {
      font-size: 24px;
      margin: 18px 0;
      color: #ff0040;
      text-shadow: 0 0 10px #ff0040;
    }

    #finalBest {
      font-size: 18px;
      margin-bottom: 10px;
      color: #ccc;
    }

    #powerupInfo {
      font-size: 12px;
      margin-top: 18px;
      line-height: 1.7;
      color: #ccc;
    }

    #bestBlock {
      font-size: 12px;
      margin-top: 12px;
      color: #aaa;
      line-height: 1.8;
    }
  </style>
</head>
<body>
  <div id="bg-grid"></div>

  <div id="ui">
    <span id="time">TIME: 60s</span>
    <span id="score">SCORE: 0</span>
    <span id="shield"><span class="status-off">SHIELD: OFF</span></span>
    <span id="slowmo"><span class="status-off">SLOWMO: OFF</span></span>
    <span id="mult"><span class="status-off">X2: OFF</span></span>
    <span id="magnet"><span class="status-off">+M+: OFF</span></span>
    <span id="diffLabel">DIFF: EASY</span>
    <span id="modeLabel">MODE: ARCADE</span>
  </div>

  <div id="menu">
    <h1>./ GRAD DODGE v4</h1>
    <p>– Dodge X enemies!</p>
    <p>– Collect + for +10 points!</p>
    <p>– Collect * for SHIELD (1 hit)!</p>
    <p>– Collect S to SLOW TIME!</p>
    <p>– Collect X2 for SCORE x2!</p>
    <p>– Collect +M+ for MAGNET!</p>
    <br />

    <div id="difficultyButtons">
      <button class="btn btn-small btn-diff-active" data-diff="easy">EASY</button>
      <button class="btn btn-small" data-diff="normal">NORMAL</button>
      <button class="btn btn-small" data-diff="hard">HARD</button>
    </div>

    <div id="modeButtons">
      <button class="btn btn-small btn-diff-active" data-mode="arcade">ARCADE (60s)</button>
      <button class="btn btn-small" data-mode="survival">SURVIVAL (∞)</button>
    </div>

    <br/>
    <button class="btn" id="startBtn">./ START GAME</button>

    <div id="bestBlock">
      <div>
        BEST ARCADE EASY: <span id="bestArcadeEasy">0</span> |
        BEST ARCADE NORMAL: <span id="bestArcadeNormal">0</span> |
        BEST ARCADE HARD: <span id="bestArcadeHard">0</span>
      </div>
      <div>
        BEST SURVIVAL EASY: <span id="bestSurvivalEasy">0</span> |
        BEST SURVIVAL NORMAL: <span id="bestSurvivalNormal">0</span> |
        BEST SURVIVAL HARD: <span id="bestSurvivalHard">0</span>
      </div>
    </div>
  </div>

  <canvas id="gameCanvas"></canvas>

  <div id="gameOver">
    <h2>./ GAME OVER</h2>
    <div id="finalScore">FINAL SCORE: 0</div>
    <div id="finalBest">BEST (MODE): 0</div>
    <button class="btn" id="restartBtn">./ RESTART</button>
    <br /><br />
    <button class="btn" id="menuBtn" style="background: #666;">./ MAIN MENU</button>
  </div>

  <script>
    function createBgGrid() {
      const grid = document.getElementById('bg-grid');
      let content = '';
      const cols = Math.floor(window.innerWidth / 14);
      const rows = Math.floor(window.innerHeight / 16);

      for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) content += './';
        content += '\n';
      }
      grid.textContent = content;
    }

    createBgGrid();
    window.addEventListener('resize', createBgGrid);

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    ctx.imageSmoothingEnabled = false;

    const GLOBAL_GAME_TIME = 60000;   
    const POWERUP_DURATION = 5000;

    const difficulties = {
      easy: {
        label: 'EASY',
        enemySpawnBase: 0.055,
        enemySpeedBase: { min: 1.6, max: 3.1 },
        plusChance: 0.03,
        shieldChance: 0.012,
        slowmoChance: 0.012,
        multChance: 0.012,
        magnetChance: 0.01
      },
      normal: {
        label: 'NORMAL',
        enemySpawnBase: 0.07,
        enemySpeedBase: { min: 2.1, max: 4.6 },
        plusChance: 0.018,
        shieldChance: 0.007,
        slowmoChance: 0.007,
        multChance: 0.01,
        magnetChance: 0.008
      },
      hard: {
        label: 'HARD',
        enemySpawnBase: 0.09,
        enemySpeedBase: { min: 2.7, max: 5.7 },
        plusChance: 0.015,
        shieldChance: 0.002,
        slowmoChance: 0.002,
        multChance: 0.008,
        magnetChance: 0.006
      }
    };

    const modes = {
      arcade: { label: 'ARCADE', hasTimeLimit: true },
      survival: { label: 'SURVIVAL', hasTimeLimit: false }
    };

    let currentDifficultyKey = 'easy';
    let currentModeKey = 'arcade';
    let gameConfig = { ...difficulties[currentDifficultyKey] };

    function makeHSKey(modeKey, diffKey) {
      return `${modeKey}_${diffKey}`; 
    }

    const HS_KEY = 'dodgePlusHighscores_v3_modes';
    let highscores = loadHighscores();
    updateBestBlock();

    const powerups = {
      shield: { active: false, endTime: 0 },
      slowmo: { active: false, endTime: 0 },
      mult: { active: false, endTime: 0 },
      magnet: { active: false, endTime: 0 }
    };

    function emptyHighscores() {
      return {
        arcade_easy: 0, arcade_normal: 0, arcade_hard: 0,
        survival_easy: 0, survival_normal: 0, survival_hard: 0
      };
    }

    function loadHighscores() {
      try {
        const raw = localStorage.getItem(HS_KEY);
        if (!raw) return emptyHighscores();
        const parsed = JSON.parse(raw);
        return { ...emptyHighscores(), ...parsed };
      } catch (e) {
        return emptyHighscores();
      }
    }

    function saveHighscores() {
      localStorage.setItem(HS_KEY, JSON.stringify(highscores));
    }

    function updateBestBlock() {
      document.getElementById('bestArcadeEasy').textContent = highscores.arcade_easy || 0;
      document.getElementById('bestArcadeNormal').textContent = highscores.arcade_normal || 0;
      document.getElementById('bestArcadeHard').textContent = highscores.arcade_hard || 0;

      document.getElementById('bestSurvivalEasy').textContent = highscores.survival_easy || 0;
      document.getElementById('bestSurvivalNormal').textContent = highscores.survival_normal || 0;
      document.getElementById('bestSurvivalHard').textContent = highscores.survival_hard || 0;
    }

    function tryUpdateHighscore(modeKey, diffKey, score) {
      const k = makeHSKey(modeKey, diffKey);
      if (score > (highscores[k] || 0)) {
        highscores[k] = score;
        saveHighscores();
        updateBestBlock();
        return true;
      }
      return false;
    }

    document.getElementById('difficultyButtons').addEventListener('click', (e) => {
      const btn = e.target.closest('button[data-diff]');
      if (!btn || !difficulties[btn.dataset.diff]) return;

      currentDifficultyKey = btn.dataset.diff;
      gameConfig = { ...difficulties[currentDifficultyKey] };

      document.querySelectorAll('#difficultyButtons button').forEach(b => b.classList.remove('btn-diff-active'));
      btn.classList.add('btn-diff-active');

      document.getElementById('diffLabel').textContent = `DIFF: ${gameConfig.label}`;
    });

    document.getElementById('modeButtons').addEventListener('click', (e) => {
      const btn = e.target.closest('button[data-mode]');
      if (!btn || !modes[btn.dataset.mode]) return;

      currentModeKey = btn.dataset.mode;

      document.querySelectorAll('#modeButtons button').forEach(b => b.classList.remove('btn-diff-active'));
      btn.classList.add('btn-diff-active');

      document.getElementById('modeLabel').textContent = `MODE: ${modes[currentModeKey].label}`;
    });

    let gameRunning = false;
    const PLAYER_SIZE = 28;
    const FONT = 'bold 26px monospace';
    let player = { x: 0, y: 0, size: PLAYER_SIZE };

    let enemies = [];
    let collectibles = [];
    let score = 0;
    let startTime = 0;
    let scoreMultiplier = 1;

    const keys = {};
    document.addEventListener('keydown', (e) => {
      keys[e.code] = true;
      if (e.code === 'Space' && !gameRunning) e.preventDefault();
    });
    document.addEventListener('keyup', (e) => keys[e.code] = false);

    function createEnemy(difficultyFactor = 1) {
      return {
        x: Math.random() * (canvas.width - PLAYER_SIZE) + PLAYER_SIZE / 2,
        y: -PLAYER_SIZE,
        size: PLAYER_SIZE,
        speed: gameConfig.enemySpeedBase.min +
          Math.random() * (gameConfig.enemySpeedBase.max - gameConfig.enemySpeedBase.min) * difficultyFactor
      };
    }

    function createCollectible(type) {
      return {
        type: type || '+',
        x: Math.random() * (canvas.width - PLAYER_SIZE * 2) + PLAYER_SIZE,
        y: -PLAYER_SIZE,
        size: PLAYER_SIZE,
        speed: 1.5 + Math.random() * 1.5
      };
    }

    function collided(obj1, obj2) {
      const dx = obj1.x - obj2.x;
      const dy = obj1.y - obj2.y;
      return Math.sqrt(dx * dx + dy * dy) < (obj1.size / 2 + obj2.size / 2) * 0.9;
    }

    function clampPlayer() {
      player.x = Math.max(player.size / 2, Math.min(canvas.width - player.size / 2, player.x));
      player.y = Math.max(player.size / 2, Math.min(canvas.height - player.size / 2, player.y));
    }

    function activatePowerup(type) {
      powerups[type].active = true;
      powerups[type].endTime = Date.now() + POWERUP_DURATION;

      const el = document.getElementById(type);
      const status = el.querySelector('span');
      const labels = { shield: 'SHIELD', slowmo: 'SLOWMO', mult: 'X2', magnet: '+M+' };
      status.textContent = labels[type] + ': ON';
      status.className = 'status-on';
    }

    function deactivatePowerup(type) {
      powerups[type].active = false;

      const el = document.getElementById(type);
      const status = el.querySelector('span');
      const labels = { shield: 'SHIELD', slowmo: 'SLOWMO', mult: 'X2', magnet: '+M+' };
      status.textContent = labels[type] + ': OFF';
      status.className = 'status-off';
    }

    function updatePowerups() {
      Object.keys(powerups).forEach(type => {
        if (powerups[type].active && Date.now() >= powerups[type].endTime) deactivatePowerup(type);
      });
      scoreMultiplier = powerups.mult.active ? 2 : 1;
    }

    function magnetCollectibles() {
      if (!powerups.magnet.active) return;

      for (let i = collectibles.length - 1; i >= 0; i--) {
        const c = collectibles[i];
        if (c.type !== '+') continue;

        const dx = player.x - c.x;
        const dy = player.y - c.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist < 120) {
          c.x += (dx / dist) * 4;
          c.y += (dy / dist) * 4;
        }

        if (collided(player, c)) {
          score += 10 * scoreMultiplier;
          collectibles.splice(i, 1);
        }
      }
    }

    function update() {
      if (!gameRunning) return;

      const baseSpeed = 8;
      const moveSpeed = powerups.slowmo.active ? baseSpeed * 0.7 : baseSpeed;
      if (keys['ArrowLeft'] || keys['KeyA']) player.x -= moveSpeed;
      if (keys['ArrowRight'] || keys['KeyD']) player.x += moveSpeed;
      if (keys['ArrowUp'] || keys['KeyW']) player.y -= moveSpeed;
      if (keys['ArrowDown'] || keys['KeyS']) player.y += moveSpeed;

      clampPlayer();

      const elapsed = Date.now() - startTime;
      const timeFactor = Math.min(1.8, 1 + elapsed / GLOBAL_GAME_TIME); 
      const slowFactor = powerups.slowmo.active ? 0.4 : 1;

      enemies.forEach(e => e.y += e.speed * slowFactor);
      collectibles.forEach(c => c.y += c.speed * slowFactor);

      const limit = canvas.height + 40;
      enemies = enemies.filter(e => e.y < limit);
      collectibles = collectibles.filter(c => c.y < limit);

      if (Math.random() < gameConfig.enemySpawnBase * timeFactor) enemies.push(createEnemy(timeFactor));
      if (Math.random() < gameConfig.plusChance) collectibles.push(createCollectible('+'));
      if (Math.random() < gameConfig.shieldChance) collectibles.push(createCollectible('shield'));
      if (Math.random() < gameConfig.slowmoChance) collectibles.push(createCollectible('slowmo'));
      if (Math.random() < gameConfig.multChance) collectibles.push(createCollectible('mult'));
      if (Math.random() < gameConfig.magnetChance) collectibles.push(createCollectible('magnet'));

      for (let i = enemies.length - 1; i >= 0; i--) {
        if (collided(player, enemies[i])) {
          if (powerups.shield.active) {
            enemies.splice(i, 1);
            deactivatePowerup('shield');
          } else {
            gameOver();
            return;
          }
        }
      }

      for (let i = collectibles.length - 1; i >= 0; i--) {
        const item = collectibles[i];
        if (collided(player, item)) {
          if (item.type === '+') score += 10 * scoreMultiplier;
          else activatePowerup(item.type);
          collectibles.splice(i, 1);
        }
      }

      magnetCollectibles();
      updatePowerups();

      document.getElementById('score').textContent = `SCORE: ${score}`;

      if (modes[currentModeKey].hasTimeLimit) {
        const timeLeft = Math.max(0, GLOBAL_GAME_TIME - elapsed);
        document.getElementById('time').textContent = `TIME: ${Math.floor(timeLeft / 1000)}s`;
        if (elapsed >= GLOBAL_GAME_TIME) gameWin();
      } else {
        document.getElementById('time').textContent = 'TIME: ∞';
      }
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.font = FONT;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      if (powerups.shield.active) {
        ctx.save();
        ctx.beginPath();
        ctx.arc(player.x, player.y, player.size, 0, Math.PI * 2);
        ctx.strokeStyle = '#00bfff';
        ctx.lineWidth = 3;
        ctx.shadowColor = '#00bfff';
        ctx.shadowBlur = 15;
        ctx.stroke();
        ctx.restore();
      }

      ctx.fillStyle = '#00ff41';
      ctx.shadowColor = '#00ff41';
      ctx.shadowBlur = 12;
      ctx.fillText('./', player.x, player.y);
      ctx.shadowBlur = 0;

      enemies.forEach(enemy => {
        ctx.fillStyle = '#ff0040';
        ctx.shadowColor = '#ff0040';
        ctx.shadowBlur = 12;
        ctx.fillText('X', enemy.x, enemy.y);
        ctx.shadowBlur = 0;
      });

      const colors = {
        '+': '#bb00ff',
        shield: '#00bfff',
        slowmo: '#ffff00',
        mult: '#ff44ff',
        magnet: '#44ff44'
      };
      const icons = { shield: '*', slowmo: 'S', mult: 'X2', magnet: '+M+' };

      collectibles.forEach(c => {
        const color = colors[c.type] || '#bb00ff';
        const icon = icons[c.type] || c.type;
        ctx.fillStyle = color;
        ctx.shadowColor = color;
        ctx.shadowBlur = 12;
        ctx.fillText(icon, c.x, c.y);
        ctx.shadowBlur = 0;
      });
    }

    function gameLoop() {
      update();
      draw();
      requestAnimationFrame(gameLoop);
    }

    function resetPowerupsUI() {
      Object.keys(powerups).forEach(type => {
        powerups[type].active = false;
        powerups[type].endTime = 0;

        const el = document.getElementById(type);
        if (!el) return;
        const status = el.querySelector('span');
        const labels = { shield: 'SHIELD', slowmo: 'SLOWMO', mult: 'X2', magnet: '+M+' };
        status.textContent = labels[type] + ': OFF';
        status.className = 'status-off';
      });
      scoreMultiplier = 1;
    }

    function startGame() {
      gameConfig = { ...difficulties[currentDifficultyKey] };

      gameRunning = true;
      startTime = Date.now();
      score = 0;

      player.x = canvas.width / 2;
      player.y = canvas.height - 100;

      enemies = [];
      collectibles = [];
      resetPowerupsUI();

      document.getElementById('diffLabel').textContent = `DIFF: ${gameConfig.label}`;
      document.getElementById('modeLabel').textContent = `MODE: ${modes[currentModeKey].label}`;
      document.getElementById('score').textContent = 'SCORE: 0';
      document.getElementById('time').textContent = modes[currentModeKey].hasTimeLimit ? 'TIME: 60s' : 'TIME: ∞';

      document.getElementById('menu').style.display = 'none';
      document.getElementById('gameOver').style.display = 'none';
      canvas.style.display = 'block';
      document.getElementById('ui').style.opacity = '1';
    }

    function showMenu() {
      canvas.style.display = 'none';
      document.getElementById('gameOver').style.display = 'none';
      document.getElementById('menu').style.display = 'block';
      document.getElementById('ui').style.opacity = '0';
    }

    function endGameCommon(title) {
      gameRunning = false;

      const isNewBest = tryUpdateHighscore(currentModeKey, currentDifficultyKey, score);
      const bestForMode = highscores[makeHSKey(currentModeKey, currentDifficultyKey)] || 0;

      document.getElementById('finalScore').textContent = `FINAL SCORE: ${score}`;
      document.getElementById('finalBest').textContent =
        `BEST ${modes[currentModeKey].label} ${gameConfig.label}: ${bestForMode}` + (isNewBest ? ' (NEW!)' : '');

      const go = document.getElementById('gameOver');
      go.style.borderColor = title.includes('WIN') ? '#00ff41' : '#ff0040';
      go.style.boxShadow = `0 0 40px ${title.includes('WIN') ? 'rgba(0, 255, 65, 0.5)' : 'rgba(255, 0, 64, 0.5)'}`;
      go.querySelector('h2').textContent = title;
      go.style.display = 'block';
      bindGameOverButtons();
    }

    function gameOver() { endGameCommon('./ GAME OVER'); }
    function gameWin() { endGameCommon('./ YOU WIN!'); }

    function bindGameOverButtons() {
      document.getElementById('restartBtn').onclick = () => {
        document.getElementById('gameOver').style.display = 'none';
        startGame();
      };
      document.getElementById('menuBtn').onclick = () => {
        document.getElementById('gameOver').style.display = 'none';
        showMenu();
      };
    }

    document.getElementById('startBtn').onclick = startGame;
    gameLoop();
  </script>
</body>
</html>
